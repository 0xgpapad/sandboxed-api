About library's functions:
    * pffft_aligned_malloc(size_t)
        returns an allocated array considering the alignment offset
    * pffft_aligned_free(void *)
        frees the memory
    * pffft_simd_size()
        returns the SIMD_SZ = 4 (regarding simd vector)
    * pffft_new_setup(int, ...)
        with a fft size (first argument) being a multiple of 16, 32.

Deleted part (validate function)
    /*for (pass = 0; pass < 2; pass++) {
      if (pass == 0) {
        for (k = 0; k < Nfloat; k++) {
          ref_[k] = in_[k] = frand() * 2 - 1;
          out_[k] = 1e30;
        }

        if (!cplx) {
          api.rffti(N, wrk_.PtrBoth()).IgnoreError();
          api.rfftf(N, ref_.PtrBoth(), wrk_.PtrBoth()).IgnoreError();

          {
            float refN = ref_[N - 1];
            for (k = N - 2; k >= 1; --k) {
              ref_[k + 1] = ref_[k];
            } 
            ref_[1] = refN;
          }
        } else {
          api.cffti(N, wrk_.PtrBoth()).IgnoreError();
          api.cfftf(N, ref_.PtrBoth(), wrk_.PtrBoth()).IgnoreError();
        } 
      }

      for (k = 0; k < Nfloat; ++k) {
        ref_max = MAX(ref_max, fabs(ref_[k]));
      }

      if (pass == 0) {
        api.pffft_transform(s_reg.PtrBefore(), in_.PtrBoth(), tmp_.PtrBoth(), wrk_.PtrBoth(), PFFFT_FORWARD).IgnoreError();

        memcpy(tmp2, tmp, Nbytes);
        memcpy(tmp, in, Nbytes);

        api.pffft_transform(s_reg.PtrBefore(), tmp_.PtrBoth(), tmp_.PtrBoth(), wrk_.PtrBoth(), PFFFT_FORWARD).IgnoreError();

        printf("Forward transformation test passed.\n");

        api.pffft_zreorder(s_reg.PtrBefore(), tmp_.PtrBoth(), out_.PtrBoth(), PFFFT_FORWARD).IgnoreError();
        api.pffft_zreorder(s_reg.PtrBefore(), out_.PtrBoth(), tmp_.PtrBoth(), PFFFT_BACKWARD).IgnoreError();

        printf("Reordering test passed.\n");
      } else {
        api.pffft_transform_ordered(s_reg.PtrBefore(), in_.PtrBoth(), tmp_.PtrBoth(), wrk_.PtrBoth(), PFFFT_FORWARD).IgnoreError();

      }
    } */

        
MACRO for testing
TEST(AssignOrReturn, AssignsMultipleVariablesInSequence) {
  auto func = []() -> absl::Status {
    int value1;
    SAPI_ASSIGN_OR_RETURN(value1, StatusOr<int>(1));
    EXPECT_EQ(1, value1);
    int value2;
    SAPI_ASSIGN_OR_RETURN(value2, StatusOr<int>(2));
    EXPECT_EQ(2, value2);
    int value3;
    SAPI_ASSIGN_OR_RETURN(value3, StatusOr<int>(3));
    EXPECT_EQ(3, value3);
    int value4;
    SAPI_ASSIGN_OR_RETURN(value4,
                          StatusOr<int>(absl::UnknownError("EXPECTED"
  int value1;
    SAPI_ASSIGN_OR_RETURN(value1, StatusOr<int>(1));


 // PFFFT benchmark
    /*{
      sapi::StatusOr<PFFFT_Setup *> s = api.pffft_new_setup(N, cplx ? PFFFT_COMPLEX : PFFFT_REAL);
      if (s.ok()) {
        sapi::v::GenericPtr s_reg(s.value());

        t0 = uclock_sec();  
        for (iter = 0; iter < max_iter; ++iter) {
          printf("%s 1\n", api.pffft_transform(s_reg.PtrBoth(), X_.PtrBoth(), Z_.PtrBoth(), Y_.PtrBoth(), PFFFT_FORWARD).ToString().c_str());
          printf("%s 2\n", api.pffft_transform(s_reg.PtrBoth(), X_.PtrBoth(), Z_.PtrBoth(), Y_.PtrBoth(), PFFFT_FORWARD).ToString().c_str());
        }
        t1 = uclock_sec();
        printf("%s 3 \n", api.pffft_destroy_setup(s_reg.PtrBoth()).ToString().c_str());

      
        flops = (max_iter*2) * ((cplx ? 5 : 2.5) * N * log((double)N) / M_LN2); 
        show_output("PFFFT", N, cplx, flops, t0, t1, max_iter);
      } else {
        fprintf(stderr, "s NULL :(\n\n");
      }
    }*/
    